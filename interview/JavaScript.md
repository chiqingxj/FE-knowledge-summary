# 『 JavaScript 』
## 数据类型
1. 有哪些数据类型？
  原始类型：number，string，boolean，null，undefined，symbol，bigint
  引用类型：object (包括 array，function，reg，math，date...)

2. JS 中变量的存储方式
  原始类型存储在栈中，引用类型的内容存储在堆内存中，栈内存中存储指向对象的指针。

3. 如何判断两个变量相等？
  可以通过比较 == === Object.is() 之间的区别来说明

4. null 和 undefined 之间的区别
  null 表示"没有对象"，即该处不应该有值。
  undefined表示"缺少值"，就是此处应该有一个值，但是还没有定义。

5. typeof instanceOf constructor Object.prototype.toString.call()
  typeof 
  只能精准检测原始类型，不能准确的检测出引用类型的具体类型。
  注意： typeof null === 'object', typeof func === 'function', typeof 所能得到的值只有 'number', 'string', 'boolean', 'undefined', 'object', 'function'。
  instanceOf
  实质是通过检测原型链上原型对象来判断的。
  注意：instanceOf 只能检测对象，且所有对象 instanceOf Object 都会返回 true，且有原型链断裂的风险。
  constructor
  和 instanceOf 的原理类似
  注意：有原型链断裂的风险。
  Object.prototype.toString.call()
  最稳健的方法


## 作用域与闭包
1. 什么是执行上下文(Execution Context)？
  JS代码执行时，会存在以下三种执行环境：全局环境，函数环境，eval 函数环境。
  浏览器首次加载 JS 代码时，默认情况下会进入全局执行上下文，若在全局环境中调用函数时，会创建一个新的函数执行上下文，并将它压入调用栈的栈顶，如果在这个函数内部再调用一个函数，同样会再创建一个新的函数执行上下文
  并压入栈顶，浏览器将始终执行位于栈顶的执行上下文，且一旦函数执行完成，将会将该函数的执行上下文从栈中弹出。每个函数调用都会创建一个新的执行上下文，甚至是对自身的调用。

  在 JS 解释器内部，对执行上下文的每次调用都会有两个阶段：(1)创建阶段，在执行任何代码之前 (2)代码执行阶段。
  在创建阶段，会做以下工作：创建作用域链 -> 创建变量、函数、参数(变量对象) -> 确定'this'的值。
  在执行阶段，会做以下工作：为函数中的变量赋值并执行代码。

  可以在概念上对执行上下文表示为具有三个属性的对象：
  ```javascript
  execContextObject = {
      scopeChain: {
          // 变量对象 + 所有的父级执行上下文中的变量对象
      },
      variableObject: {
          // 参数，变量，内部函数声明
      },
      this: {}
  }
  ```
  以下是解释器如何执行代码的伪概述：
  (1) 找到调用函数的代码
  (2) 在执行功能代码之前，创建执行上下文
  (3) 进入创建阶段：
      ① 初始化范围链
      ② 创建变量对象：
        - 创建 arguments 对象，检查参数的上下文，初始化名称和值并创建引用副本
        - 扫描上下文中的函数声明：
            - 对于找到的每个函数，在变量对象中创建一个属性，即确切的函数名称，该属性在内存中具有指向该函数的引用指针
            - 如果函数名称已经存在，则引用指针值将被覆盖
        - 扫描上下文中的变量声明：
            - 对于找到的每个变量声明，在变量对象中创建一个属性，即变量名称，并将该值初始化为undefined
            - 如果变量名称已经存在于变量对象中，则什么也不做，然后继续扫描 (故同时声明同名的函数和变量，得到的是函数)
      ③ 确定上下文中“ this”的值。
  (4) 激活/代码执行阶段：
      - 在上下文中运行/解释功能代码，并在逐行执行代码时分配变量值。

2. 什么是作用域？
  JS 中的作用域是词法作用域，而不是动态作用域。在代码编写时就已经确定，作用域的具体内容就是当前执行上下文的变量对象。
  每个函数都有一个与之对应的执行上下文，该执行上下文包含一个变量对象(VO)，每个执行上下文的作用域链属性是当前上下文的变量对象 +所有父级执行上下文的变量对象的集合。

3. 什么是闭包？
  闭包就是内部函数始终可以访问其外部函数的变量和参数，即使在外部函数完成 return 后也是如此。

4. 何时使用闭包？
  (1) 封装 -> 模块：公开公共接口，隐藏内部实现
  (2) 回调
  (3) 作为参数

5. 闭包的缺点
  (1) 导致作用域链过长
  (2) 可能导致循环引用

6. 如何解析对象属性？
  JS 解释器尝试解析属性或标识符时，将首先使用作用域链来定位对象。找到对象后，再遍历该对象的原型链以查找属性名称。


## 原型与继承
1. 原型与原型链
  每个对象都有一个 __proto__ 属性，指向它的原型对象。
  每个函数都有一个 prototype 属性，指向它实例的原型对象。

  instance.__proto__.__proto__... 一直到 null，这一系列的原型对象构成一条原型链。

2. 继承
  手写实现


## 