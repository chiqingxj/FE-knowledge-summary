## TCP 是什么？
TCP 协议是**面向连接**、**可靠**的**基于字节流**的**传输协议**。

## TCP 做了些什么？
+ TCP 提供一种面向连接的、可靠的字节流服务。
+ 在一个 TCP 连接中，仅有两方进行彼此通信。广播和多播不能用于 TCP。
+ TCP 使用校验和，确认和重传机制来保证可靠传输。
+ TCP 给数据分节进行排序，并使用累积确认保证数据的顺序不变和非重复。
+ TCP 使用滑动窗口机制来实现流量控制，通过动态改变窗口的大小进行拥塞控制

TCP 通过检验和、序列号、确认应答、重发控制、连接管理以及窗口控制等机制实现可靠性传输。

## TCP 报文头
![TCP 报文头](http://47.98.159.95/my_blog/tcp/005.jpg)
**源端口和目标端口**

如何标识唯一标识一个连接？答案是 TCP 连接的四元组——源 IP、源端口、目标 IP 和目标端口。

源端口和目标端口分别占用16位，表示源端口号和目的端口号，用于区别主机中的不同进程。

**序列号 (Sequence Number)**

字段长 32 位，序列号是指**发送数据的位置**，每发送一次数据，就**累加**一次该数据字节数的大小。序列号不是从0 或者 1 开始，而是 **ISN**，通过 SYN 包传给接收端主机。

ISN (Initial Sequence Number 初始序列号)，三次握手过程中，双方会用过 SYN 报文来交换彼此的 ISN。

ISN 并不是一个固定的值，而是每 4 ms 加 1，溢出则回到 0，这个算法使得猜测 ISN 变得很困难。

那为什么要这么做？

如果 ISN 被攻击者预测到，要知道源 IP 和源端口号都是很容易伪造的，当攻击者猜测 ISN 之后，直接伪造一个 RST 后，就可以强制连接关闭的，这是非常危险的。

而动态增长的 ISN 大大提高了猜测 ISN 的难度。

**确认号 (Acknowledgement Number)**

确认号字段长度为 32 位。用来**告知对方下一个期望接收的序列号，**小于 ACK **的所有字节已经全部收到。**实际上，它是指已收到从头到确认应答号减一为止的数据。发送端收到这个确认应答以后可以认为在这个序号以前的数据都已经正常接收了。**ACK=1 时有效**。 

**数据偏移 (Data Offset)**

该字段表示 **TCP 所传输的数据部分应该从 TCP 包的哪个位开始计算**，当然也可以把它看作 TCP 首部的长度。该字段长 4 位，单位为 4 字节 (即 32 位)。不包含选项字段的话，数据偏移字段可以设置为 5 。反之，如果该字段的值为 5，那说明从 TCP 包的最一开始到 20 字节为止都是 TCP 首部，余下的部分为 TCP 数据。

**保留 (Reserved)**

该字段主要是为了以后扩展使用，其长度为 4 位，一般设置成 0 ，即使收到的包在该字段不为 0 ，此包也不会被丢弃。

**控制位 (Control Flag)**

字段长为 8 位，从左往右分别为：

+ CWR (Congestion Window Reduced)

  CWR 标志和后面的 ECE 标志都用于 IP 首部的 ECN 字段，ECE 字段为 1 时，则**通知对方已将拥塞窗口缩小**。

+ ECE (ECN-Echo):

  ECE 标志表示 ECN-Echo。置为 1 ，代表会**通知对方，从对方到这边的网络有拥塞**。

+ URD (Urgent Flag):

  该位为1，代表包中有**需要紧急处理**的数据。

+ ACK (Acknowledgement Flag):

  该位为1，代表**确认应答**的字段变有效。

+ PSH (Push Flag):

  该位为1，表示需要将受到的数据立即**传给上层应用协议**。为 0 表示不用立即传，先进行缓存。

+ RST (Reset Flag):

  该位为1，表示 TCP 连接中**出现异常必须强制断开连接**。

+ SYN (Synchronize Flag):

  为1表示**希望建立连接**，并在其序列号字段进行序列号的随机初始值的设定。

+ FIN (Fin Flag):

  该位为1，表示今后再也**没有数据发送**了，**希望断开连接**。

**校验和 (Checksum)**

TCP 的校验和和 UDP 的相似，区别在于 **TCP 的校验和无法关闭**（UDP 可以在校验和字段填 0 ，来关闭校验），与 UDP 数据报一样，TCP 数据报段在计算校验和时也包括一个 12 字节长的伪首部。

注：TCP 数据报段**伪首部**起到**双重校验**的作用：

+ 通过伪首部的 IP 地址检验，TCP 可以确认 IP 没有接受不是发给本机的数据报；

+ 通过伪首部的协议字段检验，TCP 可以确认 IP 没有把应该传给其他高层协议（比如UDP、ICMP或者IGMP）的数据报传给 TCP 。

**窗口大小（Window size）**

该字段为 16 位，滑动窗口大小 。

**紧急指针（Urgent pointer）**

该字段为 16 位，只有在 URG 控制位为 1 的时候有效。该字段的数值表示本报文段中紧急数据的指针。

**选项（Options）**

选项字段用于提高 TCP 的传输性能，因为根据数据偏移（首部长度）进行控制，所以其长度最大为 40 字节。另外，选项字段尽量调整其为 32 位的整数倍。

## TCP 滑动窗口
窗口是**缓存的一部分，用来暂时存放字节流**。发送方和接收方各有一个窗口，接收方通过 TCP 报文段中的窗口字段告诉发送方自己的窗口大小，发送方根据这个值和其它信息设置自己的窗口大小。

+ **发送窗口**

  发送窗口内的字节都允许被发送，接收窗口内的字节都允许被接收。如果发送窗口左部的字节已经发送并且收到了确认，那么就将发送窗口向右滑动一定距离，直到左部第一个字节不是已发送并且已确认的状态；接收窗口的滑动类似，接收窗口左部字节已经发送确认并交付主机，就向右滑动接收窗口。

+ **接收窗口**

  接收窗口只会对窗口内最后一个按序到达的字节进行确认，例如接收窗口已经收到的字节为 {31， 32， 34， 35}，其中 {31， 32} 按序到达，而 {34， 35} 就不是，因此只对字节 32 进行确认。发送方得到一个字节的确认之后，就知道这个字节之前的所有字节都已经被接收。

**滑动窗口的作用**

TCP 使用滑动窗口做**流量控制**和**乱序重排**。

## TCP 可靠传输
TCP 使用**超时重传**来实现可靠传输：如果一个已经发送的报文段**在超时时间内没有收到确认**，那么就重传这个报文段。

一个报文段从发送再到接收到确认所经过的时间称为**往返时间 RTT**，加权平均往返时间 RTTs 计算如下：

超时时间 RTO 应该略大于 RTTs，TCP 使用的超时时间计算如下：>>>>>>?????TODO

其中 RTTd 为偏差。

## TCP 流量控制
流量控制是为了**控制发送方发送速率**，保证接收方来得及接收。

接收方发送的确认报文中的窗口字段可以用来控制发送方窗口大小，从而影响发送方的发送速率。将窗口字段设置为 0，则发送方不能发送数据。

## TCP 拥塞控制
如果网络出现拥塞，分组将会丢失，此时发送方会继续重传，从而导致网络拥塞程度更高。因此当出现拥塞时，应当控制发送方的速率。这一点和流量控制很像，但是出发点不同。

流量控制是为了让接收方能来得及接受，而拥塞控制是为了降低整个网络的拥塞程度。

TCP 主要通过四种算法来进行拥塞控制：**慢开始、拥塞避免、快重传、快恢复**。

发送方需要维护一个叫做**拥塞窗口**（cwnd）的状态变量。

注意拥塞窗口与发送方窗口的区别，**拥塞窗口只是一个状态变量**，**实际**决定发送方能发送多少数据的是发送方窗口。

为了便于讨论，做如下假设：

1. 接收方有足够大的接收缓存，因此不会发生流量控制
2. 虽然 TCP 的窗口基于字节，但是这里设窗口的大小单位为报文段

+ **慢开始与拥塞避免**

  发送的最初执行慢开始，令 cwnd=1，发送方只能发送 1 个报文段；

  当收到确认后，将 cwnd 加倍，因此之后发送方能够发送的报文段数量为：2、4、8 ...

  注意到慢开始每个轮次都将 cwnd 加倍，这样会让 cwnd 增长速度非常快，从而使得发送方发送的速度增长速度过快，网络拥塞的可能也就更高。

  设置一个慢开始**门限** ssthresh，当 cwnd >= ssthresh 时，进入拥塞避免，每个轮次只将 cwnd 加 1。

  如果出现了超时，则令 **ssthresh = cwnd/2**，然后**重新执行慢开始**。

+ **快重传与快恢复**

  在接收方，要求每次接收到报文段都应该发送对已收到有序报文段的确认，例如已经接收到 M1 和 M2，此时收到 M4，应当发送对 M2 的确认。

  在发送方，如果收到三个重复确认，那么可以确认下一个报文段丢失，例如收到三个 M2 ，则 M3 丢失。此时执行快重传，立即重传下一个报文段。

  在这种情况下，只是丢失个别报文段，而不是网络拥塞，因此执行**快恢复**，令 ssthresh = cwnd/2 ，cwnd = ssthresh，注意到此时直接进入拥塞避免。

## TCP 三次握手
所谓三次握手(Three-way Handshake)，是指**建立一个 TCP 连接时，需要客户端和服务器总共发送3个包**。

三次握手的目的是连接服务器指定端口，建立 TCP 连接，并同步连接双方的序列号和确认号，交换 TCP 窗口大小信息。

在 socket 编程中，客户端执行 connect() 时，将触发三次握手。
![三次握手](http://47.98.159.95/my_blog/tcp/001.jpg)
**第一次握手(SYN=1， seq=x)**

客户端发送一个 TCP 的 SYN 标志位为 1 的包，指明客户端打算连接的服务器的端口，以及初始序列号 x，保存在包头的序列号(Sequence Number)字段里。

发送完毕后，客户端进入 **SYN_SENT** 状态。

**第二次握手(SYN=1， ACK=1， seq=y， ACKnum=x+1)**

服务器发回确认包应答。即 SYN 标志位和 ACK 标志位均为 1。服务器端将自己 ISN 的值 y 放到 Seq 字段里，同时将确认序号(Acknowledgement Number)设置为发送方的 SYN +1，即 x + 1。 发送完毕后，服务器端进入 **SYN_RCVD** 状态。

**第三次握手(ACK=1，ACKnum=y+1)**

客户端再次发送确认包，SYN 标志位为 0，ACK 标志位为 1，并且把服务器发来的序列号 + 1，即 y + 1，放在确定字段中发送给对方，并且将 服务器返回的确认号，即 x + 1 放在序列号中。

发送完毕后，客户端进入 ESTABLISHED(已建立连接) 状态，当服务器端接收到这个包时，也进入 ESTABLISHED 状态，TCP 握手结束。

## TCP 四次挥手
TCP 的连接的拆除需要发送四个包，因此称为四次挥手(Four-way handshake)，也叫做改进的三次握手。

客户端或服务器均可主动发起挥手动作，在 socket 编程中，任何一方执行 close() 操作即可产生挥手操作。
![四次挥手](http://47.98.159.95/my_blog/tcp/002.jpg)
**第一次挥手(FIN=1，seq=p)**

假设客户端想要关闭连接，客户端发送一个 FIN 标志位置为 1 的包，表示自己已经没有数据可以发送了，但是仍然可以接受数据。

发送完毕后，客户端进入 **FIN_WAIT_1** 状态。

**第二次挥手(ACK=1，ACKnum=p+1)**

服务器端确认客户端的 FIN 包，发送一个确认包，表明自己接受到了客户端关闭连接的请求，但还没有准备好关闭连接。

发送完毕后，服务器端进入 **CLOSE_WAIT** 状态，客户端接收到这个确认包之后，进入 **FIN_WAIT_2** 状态，等待服务器端关闭连接。

**第三次挥手(FIN=1，seq=q)**

服务器端准备好关闭连接时，向客户端发送结束连接请求，FIN 置为 1。

发送完毕后，服务器端进入 **LAST_ACK** 状态，等待来自客户端的最后一个 ACK。

**第四次挥手(ACK=1，ACKnum=q+1)**

客户端接收到来自服务器端的关闭请求，发送一个确认包，并进入 **TIME_WAIT** 状态，等待可能出现的要求重传的 ACK 包。

服务器端接收到这个确认包之后，关闭连接，进入 **CLOSED** 状态。

客户端等待了 2MSL 之后，没有收到服务器端的 ACK ，认为服务器端已经正常关闭连接，于是自己也关闭连接，进入 **CLOSED** 状态。

## SYN攻击
**什么是 SYN 攻击（SYN Flood）？**

在三次握手过程中，服务器发送 SYN-ACK 之后，收到客户端的 ACK 之前的 TCP 连接称为半连接(half-open connect)。此时服务器处于 SYN_RCVD 状态。当收到 ACK 后，服务器才能转入 ESTABLISHED 状态。

SYN 攻击指的是，**攻击客户端在短时间内伪造大量不存在的 IP 地址，向服务器不断地发送 SYN 包，服务器回复确认包，并等待客户的确认**。

由于源地址是不存在的，**服务器需要不断的重发直至超时**，这些伪造的 SYN 包将**长时间占用未连接队列**，导致**正常的 SYN 请求被丢弃**，导致目标系统运行缓慢，严重者会引起网络堵塞甚至系统瘫痪。

由于是不存在的 IP，服务端长时间收不到客户端的 ACK，会导致服务端不断重发数据，直到耗尽服务端的资源。

SYN 攻击是一种典型的 DoS/DDoS 攻击。

**如何检测 SYN 攻击？**

检测 SYN 攻击非常的方便，当你在服务器上看到大量的半连接状态时，特别是源IP地址是随机的，基本上可以断定这是一次SYN攻击。在 Linux/Unix 上可以使用系统自带的 netstats 命令来检测 SYN 攻击。

```
# netstat -na TCP | grep SYN_RECV | more，
```

**如何防御 SYN 攻击？**

SYN攻击不能完全被阻止，除非将TCP协议重新设计。

我们所做的是尽可能的减轻SYN攻击的危害，常见的防御 SYN 攻击的方法有如下几种：

+ 缩短超时（SYN Timeout）时间
+ 减少 SYN + ACK 重试次数，避免大量的超时重发
+ 增加 SYN 连接，即增加半连接队列的容量
+ 过滤网关防护
+ SYN Cookies 技术，在服务端接收到 SYN 后不立即分配连接资源，而是根据这个 SYN 计算出一个 Cookie，连同第二次握手回复给客户端，在客户端回复 ACK 的时候带上这个 Cookie 值，服务端验证 Cookie 合法之后才分配连接资源。

## Socket API
从 Linux 内核的角度来看，一个套接字就是通信的一个端点。 从 Linux 程序的角度来看，套接字是一个有相应描述符的文件。 普通文件的打开操作返回一个文件描述字，而 socket() 用于创建一个 socket 描述符，唯一标识一个 socket。 这个 socket 描述字跟文件描述字一样，后续的操作都有用到它，把它作为参数，通过它来进行一些操作。

**常用的函数**

+ socket()
+ bind()
+ listen()
+ connect()
+ accept()
+ write()
+ read()
+ close()

**Socket 的交互流程**

+ 服务器根据地址类型、socket 类型、以及协议来创建 socket。
+ 服务器为 socket 绑定 IP 地址和端口号。
+ 服务器 socket 监听端口号请求，随时准备接收客户端发来的连接，这时候服务器的 socket 并没有全部打开。
+ 客户端创建 socket。
+ 客户端打开 socket，根据服务器 IP 地址和端口号试图连接服务器 socket。
+ 服务器 socket 接收到客户端 socket 请求，被动打开，开始接收客户端请求，知道客户端返回连接信息。这时候 socket 进入阻塞状态，阻塞是由于 accept() 方法会一直等到客户端返回连接信息后才返回，然后开始连接下一个客户端的连接请求。
+ 客户端连接成功，向服务器发送连接状态信息。
+ 服务器 accept() 方法返回，连接成功。
+ 服务器和客户端通过网络 I/O 函数进行数据的传输。
+ 客户端关闭 socket。
+ 服务器关闭 socket。

## 常见面试题
1. **说一说 TCP 和 UDP 的区别？**

   TCP 是一个面向连接的、可靠的、基于字节流的传输层协议。

   UDP 是一个面向无连接的传输层协议。

   TCP 提供可靠的通信传输，而 UDP 则常被用于让广播和细节控制交给应用的通信传输。

   TCP 用于传输层有必要实现可靠传输的情况，由于它是面向有连接并具备顺序控制，重发控制等机制的，所	以它可以为应用提供可靠传输。

   UDP 主要用于那些对高速传输和实时性有较高要求的通信或广播通信。RIP、DHCP 等基于广播的协议也要依赖于 UDP。

   注意：TCP 并**不能保证数据一定会被对方接收到**，因为这是不可能的。TCP 能够做到的是，如果有可能，就把数据递送到接收方，否则就（通过放弃重传并且中断连接这一手段）通知用户。因此准确说 TCP 也不是 100% 可靠的协议，它所能提供的是数据的可靠递送或故障的可靠通知。

2. **为什么是三次握手？不是两次？不是四次？**

   这是因为在网络请求中，我们应该时刻记住：“网络是不可靠的，数据包是可能丢失的”。

   假设没有第三次确认，客户端向服务端发送了 SYN，请求建立连接。由于延迟，服务端没有及时收到这个包。

   于是客户端重新发送一个 SYN 包。回忆一下介绍 TCP 首部时提到的序列号，这两个包的序列号显然是相同的。

   假设服务端接收到了第二个 SYN 包，建立了通信，一段时间后通信结束，连接被关闭。这时候最初被发送的 SYN 包刚刚抵达服务端，服务端又会发送一次 ACK 确认。

   由于两次握手就建立了连接，此时的服务端就会建立一个新的连接，然而客户端觉得自己并没有请求建立连接，所以就不会向服务端发送数据。从而导致服务端建立了一个空的连接，白白浪费资源。

   在三次握手的情况下，服务端直到收到客户端的应答后才会建立连接。因此在上述情况下，客户端会接受到一个相同的 ACK 包，这时候它会抛弃这个数据包，不会和服务端进行第三次握手，因此避免了服务端建立空的连接。

   四次也可以，只是没必要，三次已经够了。

3. **三次握手过程中可以携带数据么？**

   第三次握手的时候，可以携带。前两次握手不能携带数据。

   如果前两次握手能够携带数据，那么一旦有人想攻击服务器，那么他只需要在第一次握手中的 SYN 报文中放大量数据，那么服务器势必会消耗更多的时间和内存空间去处理这些数据，增大了服务器被攻击的风险。

   第三次握手的时候，客户端已经处于ESTABLISHED状态，并且已经能够确认服务器的接收、发送能力正常，这个时候相对安全了，可以携带数据。

4. **TCP 为什么要进行四次挥手，而不是三次？**

    因为 TCP 是**全双工模式**，客户端请求关闭连接后，客户端向服务端的连接关闭（一二次挥手），服务端继续传输之前没传完的数据给客户端，服务端向客户端的连接关闭（三四次挥手）。

    所以 TCP **释放连接时服务器的 ACK 和 FIN 是分开发送的**（中间隔着数据传输），而 TCP 建立连接时服务器的 ACK 和 SYN 是一起发送的（第二次握手），所以 TCP 建立连接需要三次，而释放连接则需要四次。

    三次挥手等于说服务端将 ACK 和 FIN 的发送合并为一次挥手，这个时候**长时间的延迟 **(服务器要等发送完数据才向客户端发送 FIN) 可能会导致客户端误以为 FIN 没有到达客户端，从而让客户端不断的重发 FIN。

5. **为什么 TCP 连接时可以 ACK 和 SYN 一起发送，而释放时则 ACK 和 FIN 分开发送呢？（ACK 和 FIN 分开是指第二次和第三次挥手）**

    因为客户端请求释放时，服务器**可能还有数据需要传输给客户端**，因此服务端要先响应客户端 FIN 请求（服务端发送 ACK），表示接受到了客户端的 FIN，然后进行数据传输，传输完成后，服务端再提出 FIN 请求（服务端发送 FIN）。

    而连接时则没有中间的数据传输，因此连接时可以 ACK 和 SYN 一起发送。

6. **为什么客户端释放最后需要 TIME-WAIT 等待 2MSL(Maximum Segment Lifetime 报文最大生存时间) 呢？**

+ 为了保证客户端发送的最后一个 ACK 报文能够到达服务端。若未成功到达，则服务端超时重传 FIN+ACK 报文段，客户端再重传 ACK，并重新计时。
+ 防止已失效的连接请求报文段出现在下次连接中。TIME-WAIT 持续 2MSL 可使本连接持续的时间内所产生的所有报文段都从网络中消失，这样可使下次连接中不会出现旧的连接报文段。

    如果在处于 TIME_WAIT 状态的客户端返回 ACK 丢失，会发生什么呢？

    服务端由于没有接收到 ACK 号，可能会重新发送一次 FIN 。

    这个时候如果客户端不等待一段时间，直接关闭连接，那么通信中对应的端口号也会释放出来了，这时候如果正好有应用程序创建套接字，又恰好分配了这同一个端口号，接着服务器的 FIN 包又刚好发到。

    本来是要关闭之前的连接，但是由于端口号相同，这个 FIN 就开始断开这个刚刚建立的新连接。这所以需要等待一段时间，就是为了防止这种误操作。

    那照这样说一个 MSL 不就不够了吗，为什么要等待 2 MSL?

    + 1 个 MSL 确保四次挥手中主动关闭方最后的 ACK 报文最终能达到对端
    + 1 个 MSL 确保对端没有收到 ACK 重传的 FIN 报文可以到达

7. **说说半连接队列和全连接队列**

    三次握手前，服务端的状态从 CLOSED 变为 LISTEN , 同时在内部创建了两个队列：**半连接队列**和**全连接队列**，即 SYN 队列和 ACCEPT 队列。

    + **半连接队列**

      当客户端发送 SYN 到服务端，服务端收到以后回复 ACK 和 SYN，状态由 LISTEN 变为 SYN_RCVD，此时这个连接就被推入了 SYN 队列，也就是半连接队列。

    + **全连接队列**
      
      当客户端返回 ACK, 服务端接收后，三次握手完成。这个时候连接等待被具体的应用取走，在被取走之前，它会被推入另外一个 TCP 维护的队列，也就是全连接队列。

8. **说说 TCP 快速打开的原理(TFO TCP Fast Open)**

    **TFO 流程：**

    + 首轮三次握手
      
    首先客户端发送 SYN 给服务端，服务端接收到。
      
    注意，现在服务端不是立刻回复 SYN + ACK，而是通过计算得到一个 SYN Cookie, 将这个 Cookie 放到 TCP 报文的 Fast Open选项中，然后才给客户端返回。
      
    客户端拿到这个 Cookie 的值缓存下来。后面正常完成三次握手。
      
    首轮三次握手就是这样的流程。而后面的三次握手就不一样了。
      
    + 后面的三次握手
      
    在后面的三次握手中，客户端会将之前缓存的 Cookie、SYN 和 HTTP 请求(是的，你没看错)发送给服务端，服务端验证了 Cookie 的合法性，如果不合法直接丢弃；如果是合法的，那么就正常返回 SYN + ACK。
      
    重点来了，现在服务端能向客户端发 HTTP 响应了！这是最显著的改变，三次握手还没建立，仅仅验证了 Cookie 的合法性，就可以返回 HTTP 响应了。
      
    当然，客户端的 ACK 还得正常传过来，不然怎么叫三次握手嘛。
      
      流程如下:
      ![流程](http://47.98.159.95/my_blog/tcp/007.jpg)

    注意: 客户端最后握手的 ACK 不一定要等到服务端的 HTTP 响应到达才发送，两个过程没有任何关系。

    **TFO 的优势**

    TFO 的优势并不在与首轮三次握手，而在于后面的握手，在拿到客户端的 Cookie 并验证通过以后，可以直接返回 HTTP 响应，充分利用了1 个RTT(Round-Trip Time，往返时延)的时间提前进行数据传输，积累起来还是一个比较大的优势。

9. **能不能说说 TCP 报文中时间戳的作用？**

    timestamp 是 TCP 报文首部的一个可选项，一共占 10 个字节，格式如下:
    ```
    kind(1 字节) + length(1 字节) + info(8 个字节)
    ```
    其中 kind = 8， length = 10， info 有两部分构成: timestamp和timestamp echo，各占 4 个字节。

    那么这些字段都是干嘛的呢？它们用来解决那些问题？

    接下来我们就来一一梳理，

    **TCP 的时间戳主要解决两大问题**

    + 计算往返时延 RTT(Round-Trip Time)
    + 防止序列号的回绕问题

    **计算往返时延 RTT**

    在没有时间戳的时候，计算 RTT 会遇到的问题如下图所示:
    ![question](http://47.98.159.95/my_blog/tcp/008.jpg)

    如果以第一次发包为开始时间的话，就会出现左图的问题，RTT 明显偏大，开始时间应该采用第二次的；

    如果以第二次发包为开始时间的话，就会导致右图的问题，RTT 明显偏小，开始时间应该采用第一次发包的。

    实际上无论开始时间以第一次发包还是第二次发包为准，都是不准确的。

    那这个时候引入时间戳就很好的解决了这个问题。

    比如现在 a 向 b 发送一个报文 s1，b 向 a 回复一个含 ACK 的报文 s2 那么：

    1. a 向 b 发送的时候，timestamp 中存放的内容就是 a 主机发送时的内核时刻 ta1
    2. b 向 a 回复 s2 报文的时候，timestamp 中存放的是 b 主机的时刻 tb, timestamp echo字段为从 s1 报文中解析出来的 ta1
    3. a 收到 b 的 s2 报文之后，此时 a 主机的内核时刻是 ta2, 而在 s2 报文中的 timestamp echo 选项中可以得到 ta1, 也就是 s2 对应的报文最初的发送时刻。然后直接采用 ta2 - ta1 就得到了 RTT 的值

    **防止序列号回绕问题**

    现在我们来模拟一下这个问题。

    序列号的范围其实是在0 ~ 2 ^ 32 - 1, 为了方便演示，我们缩小一下这个区间，假设范围是 0 ~ 4，那么到达 4 的时候会回到 0。

    | 第几次发包 | 发送字节 | 对应序列号 | 状态 |
    | -------- | --- | --- | --- |
    |1 | 0 ~ 1 | 0 ~ 1 | 成功接收 |
    |2 | 1 ~ 2 | 1 ~ 2 | 滞留在网络中 |
    |3 | 2 ~ 3 | 2 ~ 3 | 成功接收 |
    |4 | 3 ~ 4 | 3 ~ 4 | 成功接收 |
    |5 | 4 ~ 5 | 0 ~ 1 | 成功接收，序列号从0开始 |
    |6 | 5 ~ 6 | 1 ~ 2 | ？？？ |

    假设在第 6 次的时候，之前还滞留在网路中的包回来了，那么就有两个序列号为1 ~ 2的数据包了，怎么区分谁是谁呢？这个时候就产生了序列号回绕的问题。

    那么用 timestamp 就能很好地解决这个问题，因为每次发包的时候都是将发包机器当时的内核时间记录在报文中，那么两次发包序列号即使相同，时间戳也不可能相同，这样就能够区分开两个数据包了。

10. **TCP 的超时重传时间是如何计算的？**

    超时重传时间(Retransmission TimeOut, 简称RTO)，它的计算跟 RTT 密切相关。这里我们将介绍两种主要的方法，一个是经典方法，一个是标准方法。

    **经典方法**

    经典方法引入了一个新的概念——SRTT(Smoothed round trip time，即平滑往返时间)，没产生一次新的 RTT. 就根据一定的算法对 SRTT 进行更新，具体而言，计算方式如下(SRTT 初始值为0):
    ```
    SRTT =  (α * SRTT) + ((1 - α) * RTT)
    ```
    其中，α 是平滑因子，建议值是0.8，范围是0.8 ~ 0.9。

    拿到 SRTT，我们就可以计算 RTO 的值了:

    ```
    RTO = min(ubound, max(lbound, β * SRTT))
    ```
    β 是加权因子，一般为1.3 ~ 2.0， lbound 是下界，ubound 是上界。

    这个算法过程还是很简单的，但是也存在一定的局限，就是在 RTT 稳定的地方表现还可以，而在 RTT 变化较大的地方就不行了，因为平滑因子 α 的范围是0.8 ~ 0.9, RTT 对于 RTO 的影响太小。

    **标准方法**

    为了解决经典方法对于 RTT 变化不敏感的问题，后面又引出了标准方法，也叫 Jacobson / Karels 算法。
    + 第一步: 计算 SRTT，公式如下:
    ```
    SRTT = (1 - α) * SRTT + α * RTT
    ```
      注意这个时候的 α跟经典方法中的α取值不一样了，建议值是1/8，也就是0.125。
    + 第二步: 计算RTTVAR(round-trip time variation)这个中间变量。
      ```
      RTTVAR = (1 - β) * RTTVAR + β * (|RTT - SRTT|)
      ```
      β 建议值为 0.25。这个值是这个算法中出彩的地方，也就是说，它记录了最新的 RTT 与当前 SRTT 之间的差值，给我们在后续感知到 RTT 的变化提供了抓手。
    + 第三步: 计算最终的RTO:
      ```
      RTO = µ * SRTT + ∂ * RTTVAR 
      ```
      µ 建议值取 1, ∂ 建议值取 4。

    这个公式在 SRTT 的基础上加上了最新 RTT 与它的偏移，从而很好的感知了 RTT 的变化，这种算法下，RTO 与 RTT 变化的差值关系更加密切。

11. **能不能说下 TCP 的流量控制？**

    **利用滑动窗口。**

    模拟一下流量控制的过程，方便大家理解。

    首先双方三次握手，初始化各自的窗口大小，均为 200 byte。

    假如当前发送端给接收端发送 100 byte，那么此时对于发送端而言，SND.NXT 当然要右移 100 byte，也就是说当前的可用窗口减少了 100 byte，这很好理解。

    现在这 100 byte 到达了接收端，被放到接收端的缓冲队列中。不过此时由于大量负载的原因，接收端处理不了这么多字节，只能处理 40 byte，剩下的 60 byte 被留在了缓冲队列中。

    注意了，此时接收端的情况是处理能力不够用了，你发送端给我少发点，所以此时接收端的接收窗口应该缩小，具体来说，缩小 60 byte，由 200 byte 变成了 140 byte，因为缓冲队列还有 60 byte 没被应用拿走。

    因此，接收端会在 ACK 的报文首部带上缩小后的滑动窗口 140 byte，发送端对应地调整发送窗口的大小为 140 byte。

    此时对于发送端而言，已经发送且确认的部分增加 40 byte，也就是 SND.UNA 右移 40 byte，同时发送窗口缩小为 140 byte。

    这也就是流量控制的过程。

12. **能不能说下 TCP 的拥塞控制？**


13. **能不能说下 TCP 的 Nagle 算法和延迟确认？**
    
    **Nagle 算法**

    试想一个场景，发送端不停地给接收端发很小的包，一次只发 1 个字节，那么发 1 千个字节需要发 1000 次。这种频繁的发送是存在问题的，不光是传输的时延消耗，发送和确认本身也是需要耗时的，频繁的发送接收带来了巨大的时延。

    而避免小包的频繁发送，这就是 Nagle 算法要做的事情。

    具体来说，Nagle 算法的规则如下:
    
    + 当第一次发送数据时不用等待，就算是 1byte 的小包也立即发送
    
    + 后面发送满足下面条件之一就可以发了:
    
      + 数据包大小达到最大段大小(Max Segment Size, 即 MSS)
      + 之前所有包的 ACK 都已接收到

    **延迟确认**

    试想这样一个场景，当我收到了发送端的一个包，然后在极短的时间内又接收到了第二个包，那我是一个个地回复，还是稍微等一下，把两个包的 ACK 合并后一起回复呢？
    
    延迟确认(delayed ack)所做的事情，就是后者，稍稍延迟，然后合并 ACK，最后才回复给发送端。TCP 要求这个延迟的时延必须小于500ms，一般操作系统实现都不会超过200ms。
    
    不过需要主要的是，有一些场景是不能延迟确认的，收到了就要马上回复:
    
    + 接收到了大于一个 frame 的报文，且需要调整窗口大小
    + TCP 处于 quickack 模式（通过tcp_in_quickack_mode设置）
    + 发现了乱序包
    
    **两者一起使用会怎样？**

    前者意味着延迟发，后者意味着延迟接收，会造成更大的延迟，产生性能问题。
    
14. **如何理解 TCP 的 keep-alive？**

    试想一个场景，当有一方因为网络故障或者宕机导致连接失效，由于 TCP 并不是一个轮询的协议，在下一个数据包到达之前，对端对连接失效的情况是一无所知的。

    这个时候就出现了 keep-alive, 它的作用就是探测对端的连接有没有失效。

    在 Linux 下，可以这样查看相关的配置:
    ```
    sudo sysctl -a | grep keepalive

    // 每隔 7200 s 检测一次
    net.ipv4.tcp_keepalive_time = 7200
    // 一次最多重传 9 个包
    net.ipv4.tcp_keepalive_probes = 9
    // 每个包的间隔重传间隔 75 s
    net.ipv4.tcp_keepalive_intvl = 75
    ```
    不过，现状是大部分的应用并没有默认开启 TCP 的 keep-alive 选项，为什么？

    站在应用的角度:
    + 7200s 也就是两个小时检测一次，时间太长
    + 时间再短一些，也难以体现其设计的初衷, 即检测长时间的死连接
    + 因此是一个比较尴尬的设计。

