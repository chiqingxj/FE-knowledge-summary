## Chrome 架构的发展
**进程与线程**

进程：启动一个程序的时候，操作系统会为该程序创建一块内存，用来存放代码、运行中的数据和一个执行任务的主线程，我们把这样的一个运行环境叫进程。

线程是依附于进程的，而进程中使用多线程并行处理能提升运算效率。

进程和线程之间的关系有以下特点：
+ 进程中的任意一线程执行出错，都会导致整个进程的崩溃。
+ 线程之间共享进程中的数据。
+ 当一个进程关闭之后，操作系统会回收进程所占用的内存。任意线程因为操作不当导致内存泄漏，当进程退出时，这些内存也会被正确回收。
+ 进程之间的内容相互隔离。需要通信的话可以使用进程间通信（IPC）的机制。


**单进程架构**

单进程浏览器是指浏览器的所有功能模块都是运行在同一个进程里，这些模块包含了网络、插件、JavaScript 运行环境、渲染引擎和页面等。
![单进程](https://static001.geekbang.org/resource/image/6d/ca/6ddad2419b049b0eb2a8036f3dfff1ca.png)
如此多的功能模块运行在一个进程里，是导致单进程浏览器不稳定、不流畅和不安全的一个主要因素。
+ 不稳定：早期浏览器插件和渲染引擎模块都是不稳定的，容易崩溃导致整个浏览器进程的崩溃。
+ 不流畅：所有页面的渲染模块、JavaScript 执行环境以及插件都是运行在同一个线程中的，这就意味着同一时刻只能有一个模块可以执行。死循环，内存泄漏等都会导致浏览器页面卡顿，不流畅。
+ 不安全：插件和页面脚本中可能含有恶意代码或资源，获取你的信息等等。


**多进程架构**
![多进程](https://static001.geekbang.org/resource/image/b6/fc/b61cab529fa31301bde290813b4587fc.png)
让我们看下这几个进程的功能：
+ 浏览器进程(主进程)：主要负责界面显示、用户交互、子进程管理，同时提供存储等功能。
+ 渲染进程：核心任务是将 HTML，CSS，JavaScript 转换为用户能够与之交互的网页。排版引擎 Blink 和 JavaScript 引擎都是运行在此进程中。默认情况下，Chrome 会为每个标签页创建一个渲染进程，运行在安全沙箱中。
+ GPU 进程：GPU 使用的初衷只是为了实现 3D CSS 效果，之后 Chrome 的界面和网页都由 GPU 绘制，所以 Chrome 在其多进程架构中也引入了 GPU 进程。
+ 网络进程：主要是面向渲染进程和浏览器进程等提供网络下载功能。
+ 插件进程：主要是负责插件的运行，因插件易崩溃，所以需要通过插件进程来隔离，以保证插件进程崩溃不会对浏览器和页面造成影响。

解决了单进程架构的 3 个问题：
+ 进程相互隔离解决了不稳定的问题。
+ 每个页面的脚本运行在自己的渲染进程中，互不影响，解决了不流畅的问题。
+ 将插件进程和渲染进程放入安全沙箱中，防止恶意获取重要信息，解决了不安全的问题。


**面向服务的架构**
![面向服务](https://static001.geekbang.org/resource/image/32/2a/329658fe821252db47b0964037a1de2a.png)


## Chrome 渲染过程
![渲染过程](https://static001.geekbang.org/resource/image/97/37/975fcbf7f83cc20d216f3d68a85d0f37.png)
**构建 DOM 树**

因为浏览器无法直接理解和使用 HTML，所以需要将 HTML 转换为浏览器能够理解的结构——DOM 树。

HTML 文件，经由 HTML 解析器解析，最终输出树状结构的 DOM。

**样式计算（Recalculate Style）**

把 CSS 转换为浏览器能够理解的结构：当渲染引擎接收到 CSS 文本时，会执行一个转换操作，将 CSS 文本转换为浏览器可以理解的结构 —— styleSheets。

转换样式表中的属性值，使其标准化：需要将所有值转换为渲染引擎容易理解的、标准化的计算值(如 em 等)。

计算出 DOM 树中每个节点的具体样式：涉及到 CSS 的继承规则和层叠规则。

**生成布局树**

计算出 DOM 树中可见元素的几何位置，我们把这个计算过程叫做布局。

这个过程分为两个阶段：

+ 创建布局树：遍历生成的 DOM 树节点，并把他们添加到布局树中。
+ 布局计算：计算布局树节点的坐标位置。

**生成图层树**

浏览器的页面实际上被分成了很多图层，这些图层叠加后合成了最终的页面。

渲染引擎还为特定的节点生成专用的图层，并生成一棵对应的图层树（LayerTree）。

通常情况下，并不是布局树的每个节点都包含一个图层，如果一个节点没有对应的层，那么这个节点就从属于父节点的图层。

+ 拥有层叠上下文属性的元素会被提升为单独的一层。

  层叠上下文也基本上是有一些特定的CSS属性创建的，一般有以下情况：

  + HTML根元素本身就具有层叠上下文
  + 普通元素设置position不为static并且设置了z-index属性，会产生层叠上下文
  + 元素的 opacity 值不是 1     
  + 元素的 transform 值不是 none
  + 元素的 filter 值不是 none
  + 元素的 isolation 值是isolate
  + will-change指定的属性值为上面任意一个

+ 需要剪裁（clip）的地方也会被创建为图层。

**图层绘制**

在完成图层树的构建之后，渲染引擎会对图层树中的每个图层进行绘制：把一个图层的绘制拆分成很多小的绘制指令，然后再把这些指令按照顺序组成一个待绘制列表。

在图层绘制阶段，输出的内容就是这些待绘制列表。

**栅格化（raster）操作**

所谓**栅格化**，是指生成**图块**并将其转换为**位图**。图块是栅格化执行的**最小单位**。

绘制列表只是用来记录绘制顺序和绘制指令的列表，而实际上**绘制操作**是由渲染引擎中的**合成线程**来完成的。

当图层的绘制列表准备好之后，主线程会把该绘制列表提交（commit）给合成线程，**合成线程会将图层划分为图块（tile）**，这些图块的大小通常是 256x256 或者 512x512。

渲染进程中专门维护了一个**栅格化线程池**，专门负责把**图块**转换为**位图数据**。

然后合成线程会按照视口附近的图块来优先生成位图，实际生成位图的操作是由栅格化线程池来执行的。

通常，栅格化过程都会使用 GPU 来加速生成，使用 GPU 生成位图的过程叫快速栅格化，或者 GPU 栅格化，生成的位图被保存在 GPU 内存中。

Chrome 底层优化首屏加载速度的一个策略: 在首次合成图块时只采用一个**低分辨率**的图片，这样首屏展示的时候只是展示出低分辨率的图片，这个时候继续进行合成操作，当正常的图块内容绘制完毕后，会将当前低分辨率的图块内容替换。

**合成和显示**

一旦所有图块都被光栅化，**合成线程**就会生成一个绘制图块的命令——“**DrawQuad**”，然后将该命令提交给**浏览器进程**。

浏览器进程里面有一个叫 **viz** 的组件，用来接收合成线程发过来的 DrawQuad 命令，然后根据 DrawQuad 命令，将其页面内容绘制到内存中，然后把这部分内存发送给显卡。

为什么发给显卡呢？了解下显示器显示图像的原理。

无论是 PC 显示器还是手机屏幕，都有一个固定的刷新频率，一般是 60 HZ，即 60 帧，也就是一秒更新 60 张图片，一张图片停留的时间约为 16.7 ms。而每次更新的图片都来自显卡的**前缓冲区**。而显卡接收到浏览器进程传来的页面后，会合成相应的图像，并将图像保存到**后缓冲区**，然后系统自动将**前缓冲区**和**后缓冲区**对换位置，如此循环更新。


## 重绘（repaint） 回流（reflow） 合成（composition）
![三元版](http://47.98.159.95/my_blog/week11/1.jpg)
+ 更新了元素的几何属性会引起回流。

  改变元素的宽度、高度等，那么浏览器会触发重新布局，解析之后的一系列子阶段，这个过程就叫回流。回流需要更新完整的渲染流水线，所以开销也是最大的。

+ 更新元素的绘制属性会引起重绘。

  如果修改了元素的背景颜色，那么布局阶段将不会被执行，因为并没有引起几何位置的变换，所以就直接进入了绘制阶段，然后执行之后的一系列子阶段，这个过程就叫重绘。

+ 渲染引擎将跳过布局和绘制，只执行后续的合成操作，我们把这个过程叫做合成。也就是大家常说的**GPU加速**


## 浏览器存储



## V8 垃圾回收机制
**代际假说**

代际假说有以下两个特点：

+ 第一个是大部分对象在内存中存在的时间很短，简单来说，就是很多对象一经分配内存，很快就变得不可访问。
+ 第二个是不死的对象，会活得更久。

V8 中会把堆分为**新生代**和**老生代**两个区域：

+ 新生代中存放的是生存时间短的对象。
+ 老生代中存放的生存时间久的对象。
![v8堆内存](https://static001.geekbang.org/resource/image/4f/af/4f9310c7da631fa5a57f871099bfbeaf.png)

新生区通常只支持 1～8M 的容量，而老生区支持的容量就大很多。

对于这两块区域，V8 分别使用两个不同的垃圾回收器，以便更高效地实施垃圾回收。

+ 副垃圾回收器，主要负责新生代的垃圾回收。
+ 主垃圾回收器，主要负责老生代的垃圾回收。

**垃圾回收器的工作流程**

1. 标记空间中活动对象和非活动对象

   + 活动对象就是还在使用的对象。
   + 非活动对象就是可以进行垃圾回收的对象。

2. 回收非活动对象所占据的内存

   其实就是在所有的标记完成之后，统一清理内存中所有被标记为可回收的对象。

3. 内存整理

    一般来说，频繁回收对象后，内存中就会存在大量不连续空间，我们把这些**不连续的内存空间**称为**内存碎片**。
    
    当内存中出现了大量的内存碎片之后，如果需要分配较大连续内存的时候，就有可能出现内存不足的情况。
    
    所以最后一步需要整理这些内存碎片，但这步其实是可选的，因为有的垃圾回收器不会产生内存碎片，比如副垃圾回收器。

**副垃圾回收器**

副垃圾回收器主要**负责新生区的垃圾回收**。

通常情况下，大多数小的对象都会被分配到新生区，所以说这个区域虽然不大，但是垃圾回收还是比较频繁的。

新生代中用 **Scavenge 算法**来处理。

Scavenge 算法，是把新生代空间对半划分为两个区域，一半是对象区域，一半是空闲区域。

新加入的对象都会存放到对象区域，当对象区域快被写满时，就需要执行一次垃圾清理操作。

**副垃圾回收器垃圾回收过程**：

+ 首先对对象区域中的垃圾做标记
+ 标记完成之后，就进入垃圾清理阶段，副垃圾回收器会把这些存活的对象复制到空闲区域中，同时它还会把这些对象有序地排列起来，所以这个复制过程，也就相当于完成了内存整理操作，复制后空闲区域就没有内存碎片了。

+ 完成复制后，对象区域与空闲区域进行角色翻转，也就是原来的对象区域变成空闲区域，原来的空闲区域变成了对象区域。

这样就完成了垃圾对象的回收操作，同时这种角色翻转的操作还能让新生代中的这两块区域无限重复使用下去。

由于新生代中采用的 Scavenge 算法，所以每次执行清理操作时，都需要将存活的对象从对象区域复制到空闲区域。

但复制操作需要时间成本，如果新生区空间设置得太大了，那么每次清理的时间就会过久，所以为了执行效率，一般**新生区的空间会被设置得比较小**。

也正是因为新生区的空间不大，所以很容易被存活的对象装满整个区域。

为了解决这个问题，JavaScript 引擎采用了**对象晋升策略**，也就是经过两次垃圾回收依然还存活的对象，会被移动到老生区中。

**主垃圾回收器**

主垃圾回收器主要**负责老生区中的垃圾回收**。

除了新生区中晋升的对象，一些大的对象会直接被分配到老生区。

老生区中的对象有两个特点：

+ 对象占用空间大
+ 对象存活时间长

由于老生区的对象比较大，若要在老生区中使用 Scavenge 算法进行垃圾回收，复制这些大的对象将会花费比较多的时间，从而导致回收执行效率不高，同时还会浪费一半的空间。

因此主垃圾回收器是采用**标记 - 清除（Mark-Sweep）**的算法进行垃圾回收的。
![标记过程](https://static001.geekbang.org/resource/image/6c/69/6c8361d3e52c1c37a06699ed94652e69.png)

**主垃圾回收器垃圾回收过程**：

+ 标记阶段

  标记阶段就是从一组根元素开始，递归遍历这组根元素，在这个遍历过程中，能到达的元素称为**活动对象**，没有到达的元素就可以判断为**垃圾数据**。

+ 清除阶段，直接将立即数据清空。
![标记-清除](https://static001.geekbang.org/resource/image/d0/85/d015db8ad0df7f0ccb1bdb8e31f96e85.png)
标记对一块内存多次执行标记 - 清除算法后，会产生大量不连续的内存碎片。而碎片过多会导致大对象无法分配到足够的连续内存，于是又产生了另外一种算法——标记 - 整理（Mark-Compact）。

**标记 - 整理（Mark-Compact）**，这个标记过程仍然与标记 - 清除算法里的是一样的，但后续步骤不是直接对可回收对象进行清理，而是让所有存活的对象都向一端移动，然后直接清理掉端边界以外的内存。
![标记-清除](https://static001.geekbang.org/resource/image/65/8c/652bd2df726d0aa5e67fe8489f39a18c.png)

**全停顿**

我们知道了 V8 是使用**副垃圾回收器和主垃圾回收器处理垃圾回收**的，不过由于 JavaScript 是运行在主线程之上的，一旦执行垃圾回收算法，都需要将正在执行的 JavaScript 脚本暂停下来，待垃圾回收完毕后再恢复脚本执行。我们把这种行为叫做**全停顿（Stop-The-World）**。
![主垃圾回收器](https://static001.geekbang.org/resource/image/98/0c/9898646a08b46bce4f12f918f3c1e60c.png)

**增量标记（Incremental Marking）算法**
在 V8 新生代的垃圾回收中，因其空间较小，且存活对象较少，所以全停顿的影响不大，但老生代就不一样了。

如果在执行垃圾回收的过程中，占用主线程时间过久，这将会**造成页面的卡顿**现象。

为了降低老生代的垃圾回收而造成的卡顿，V8 将标记过程分为一个个的子标记过程，同时让垃圾回收标记和 JavaScript 应用逻辑交替进行，直到标记阶段完成，我们把这个算法称为**增量标记（Incremental Marking）算法**。
![增量标记](https://static001.geekbang.org/resource/image/de/e7/de117fc96ae425ed90366e9060aa14e7.png)


## 浏览器存储 storage
**Cookie**

Cookie 是服务器发送到用户浏览器并保存在本地的一小块数据，它会在浏览器下次向同一服务器再发起请求时被携带并发送到服务器上。

**Cookie 作用：**
+ 会话状态管理（如用户登录状态、购物车、游戏分数或其它需要记录的信息）

+ 个性化设置（如用户自定义设置、主题等）

+ 浏览器行为跟踪（如跟踪分析用户行为等）

**生成 Cookie：**

+ Http Response Header 中的 set-cookie

  我们可以通过响应头里的 Set-Cookie 指定要存储的 Cookie 值。

```js
 // 注意不能将多个 Cookie 放在一个 Set-Cookie 中

  Set-Cookie: id=cl7; Expires=Wed, 21 Oct 2020 17:28:00 GMT;
```

+ JavaScript 中可以通过 document.cookie 可以读写 Cookie，以键值对的形式展示

```js
document.cookie = "userName=James"
```

**设置 Cookie：**

1. 第一次访问网站的时候，浏览器发送 HTTP 请求到服务器。

2. 服务器接受到请求后，会在响应头里面添加一个 Set-Cookie 选项，将 Cookie 添加到响应请求。

3. 浏览器从响应中获取到 Cookie 保存。

4. 之后每次浏览器发送请求的时候，会通过 Cookie 请求头部将 Cookie 信息发送给服务器。另外，Cookie的过期时间、域、路径、有效期、适用站点都可以根据需要来指定。

**Cookie 属性：**

+ **Name/Value**

  Cookie 以键值对形式的字符串保存，但 Cookie 中的逗号、分号、空格被当做了特殊的符号。所以当Cookie 字符串中含有这三种符号的时候，需要对其进行额外的编码操作，常用的编码/解码方式有以下三种：
  
  + escape / unescape
  + encodeURIComponent / decodeURIComponent
  + encodeURI / decodeURI
  

+ **Domain**

  Domain 指定了 Cookie 可以送达的主机名。假如没有指定，那么默认值为当前文档访问地址中的主机部分（但是不包含子域名）。

  需要注意的是，**不能跨域设置 Cookie**。

+ **Path**

  Path 指定了一个 URL 路径，这个路径必须出现在要请求的资源的路径中才可以发送 Cookie 首部。

  比如设置 Path=/docs，/docs/Web/ 下的资源会带 Cookie 首部，/test 则不会携带 Cookie 首部。

  Domain 和 Path 标识共同定义了 Cookie 的作用域：即 Cookie 应该发送给哪些 URL。

+ **expires**

  Expires 用于设置 Cookie 的过期时间。例如：

  ```javascript

  Expires=Wed, 21 Oct 2020 17:55:00 GMT;

  ```

  当 Expires 属性缺省时，表示是会话性 Cookie，值为 Session，表示的就是会话性 Cookie。

  与会话性 Cookie 相对的是持久性 Cookie，持久性 Cookies 会保存在用户的硬盘中，直至过期或者清除 Cookie。这里值得注意的是，设定的日期和时间只与客户端相关，而不是服务端。

+ **Max-Age**

  Max-Age 用于设置在 Cookie 失效之前需要经过的秒数。例如

  ```javascript
  
  Max-Age=204800;
  
  ```

  当与 Expires 属性并存，优先级高于 Expires。

  Max-Age 有三种情况：

  + 正数：持久化缓存直到过期。
  + 负数：会话性 Cookie。
  + 0：立即删除。

+ **HttpOnly**

  只能由服务端操作 Cookie，客户端脚本不得操作。设置 HTTPOnly 属性可以防止客户端脚本通过 document.cookie 等方式访问 Cookie，有助于避免 XSS 攻击。

+ **Secure**

  表示 Cookie 只通过 https 协议传输。使用 HTTPS 安全协议，可以保护 Cookie 在浏览器和 Web 服务器间的传输过程中不被窃取和篡改。

+ **SameSite**

  SameSite 属性可以让 Cookie 在跨站请求时不会被发送，从而可以阻止跨站请求伪造攻击（CSRF）。

  SameSite 可选以下三个值：
  
  + Strict：仅发送与当前 URL 相同站点的 Cookie
  
  + Lax：允许部分第三方请求携带 Cookie
  
  + None：无论是否跨站都会携带 Cookie
  
  **注意：**
  
  1. HTTP 接口不支持 SameSite=none，如果你想加 SameSite=none 属性，那么该 Cookie 就必须同时加上 Secure 属性，表示只有在 HTTPS 协议下该 Cookie 才会被发送。
  2. 需要 UA 检测，部分浏览器不能加 SameSite=none，IOS 12 的 Safari 以及老版本的一些 Chrome 会把 SameSite=none 识别成 SameSite=Strict，所以服务端必须在下发 Set-Cookie 响应头时进行 User-Agent 检测，对这些浏览器不下发 SameSite=none 属性。

**Cookie 缺点**：

+ 大小限制：4kb 的存储大小限制

+ 安全问题：易导致 CSRF 攻击

+ 网络开销：增加 HTTP 网络请求开销


由于 Cookie 的存储容量受限以及大量 Cookie 导致请求的性能开销剧增，所以为了弥补 Cookie 的这些缺陷，Web Storage 应运而生。

由此可得，Web Storage 的目的是提供一种除 Cookie 之外存储大量可以跨会话存在的数据的机制。

**sessionStorage**

sessionStorage 为每一个给定的源（given origin）维持一个独立的存储区域，该存储区域在页面会话期间可用。

sessionStorage 仅作用于会话期，受同源限制，即便是相同域名下的两个页面，只要它们不在同一个浏览器窗口中打开，那么它们的 sessionStorage 内容便无法共享。

**大小限制**：

不同的浏览器容量限制不同，一般来说是 5-10MB。如果超出使用大小限制的话会抛出**QUOTA_EXCEEDED_ERROR**错误。

**操作 sessionStorage**

+ .setItem('name', 'value')

+ .getItem('name')

+ .removeItem('name')

+ .clear()

```javascript

// 存储数据

sessionStorage.setItem("name","value")

sessionStorage.name = "value"



// 读取数据

// 可用 length 属性和 key() 方法迭代 sessionStorage 中的值或者 for-in 来迭代

sessionStorage.getItem("name")

sessionStorage.name



// 删除数据

sessionStorage.removeItem("name")

delete sessionStorage.name // 有兼容性问题



// 删除所有数据

sessionStorage.clear()

```

**localStorage**

**大小限制**

不同的浏览器容量限制不同，一般来说也是 5-10MB。

**操作 localStorage**

与 sessionStorage 一致

**cookie/sessionStorage/localStorage 的对比**

| 存储类型 | 存储容量 | 存储位置 | 数据有效期 | 数据作用域 |
| -------- | -------- | -------- | -------- | -------- |
| cookie | 4KB | 本地文件/内存 | 由 Expires 和 Max-Age 决定 | 本地和http传输过程 |
| sessionStorage | 5-10MB | 本地 | 会话期 | 会话期 |
| localStorage | 5-10MB | 本地 | 持久 | 同源窗口 |

**cookie/sessionStorage/localStorage 的使用场景**

+ 需要兼容到极低版本的浏览器（懂的都懂），那么肯定使用 Cookie 了

+ 少量的用户状态数据，且有会话性 Cookie 需求，Cookie 会更好

+ 大容量的存取，选 Storage

+ 需要持久化缓存，localStorage 吧

+ 只需要在当前页面使用的数据，sessionStorage 搞一个

+ ...

**使用 cookie/sessionStorage/localStorage 需要注意什么？**

+ 有些浏览器提供了会话恢复功能，这种情况下即使关闭了浏览器，会话期 Cookie 也会被保留下来，就好像浏览器从来没有关闭一样，这会导致 Cookie 的生命周期无限期延长。

+ 在项目中会把用成熟的库来进行操作 storage，推荐 store.js 等库。




## 浏览器通信机制



## 常见面试题
1. **如何避免重绘与回流？**
    + 使用 class 操作样式，而不是频繁操作 style。
    + 避免使用 table 布局。
    + 批量 dom 操作，例如 createDocumentFragment，或者使用框架，例如 React。
    + 对 resize、scroll 等事件进行防抖/节流处理。
    + 对 dom 属性的读写要分离。
    + 触发 repaint reflow 的操作尽量放在一起，比如改变 dom 高度和设置 margin 分开写，可能会出发两次回流。
    + will-change: transform 做优化。will-change 让渲染引擎为其单独实现一个图层，当这些变换发生时，仅仅只是利用合成线程去处理这些变换，而不牵扯到主线程，大大提高渲染效率。

2. **Domcontentloaded 和 load 的区别**
    + DOMContentLoaded
　　当初始的 HTML 文档被完全加载和解析完成之后，DOMContentLoaded 事件被触发，而无需等待样式表、图像和子框架的完成加载。
    + load
    load 仅用于检测一个完全加载的页面，页面的html、css、js、图片等资源都已经加载完之后才会触发 load 事件。
    
3. **requestAnimationFrame 实现动画为什么优于 setTimeout?**

    + **由系统来决定回调函数的执行时机**
      requestAnimationFrame 的步伐跟着系统的刷新步伐。它能保证回调函数在屏幕每一次的刷新间隔中只被执行一次，这样就不会引起丢帧现象，也不会导致动画出现卡顿的问题。

      setTimeout 的执行时间并不是确定的。因为 setTimeout 任务被放进了异步队列中，所以 setTimeout 的实际执行时间一般要比其设定的时间晚一些。

      刷新频率受**屏幕分辨率**和**屏幕尺寸**的影响，因此不同设备的屏幕刷新频率可能会不同，而 setTimeout 只能设置一个固定的时间间隔，这个时间不一定和屏幕的刷新时间相同。

    + **CPU节能**

      当页面处理未激活的状态下，该页面的屏幕刷新任务也会被系统暂停，因此跟着系统步伐走的requestAnimationFrame也会停止渲染，当页面被激活时，动画就从上次停留的地方继续执行，有效节省了CPU开销。

      使用setTimeout实现的动画，当页面被隐藏或最小化时，setTimeout 仍然在后台执行动画任务，由于此时页面处于不可见或不可用状态，刷新动画是没有意义的，完全是浪费CPU资源。

    + **函数节流**

      在高频率事件( resize, scroll 等)中，为了防止在一个刷新间隔内发生多次函数执行，使用requestAnimationFrame 可保证每个刷新间隔内，函数只被执行一次，这样既能保证流畅性，也能更好的节省函数执行的开销。
    
4. **setTimeout 是如何实现的？**

    setTimeout 就是一个定时器，用来**指定某个函数在多少毫秒之后执行**。

    当通过 JavaScript 创建一个定时器时，**渲染进程**会将该定时器的**回调任务**添加到**延迟队列**中。源码中延迟执行队列的定义如下所示：
    ```
    DelayedIncomingQueue delayed_incoming_queue;
    ```
    当通过 JavaScript 调用 setTimeout 设置回调函数的时候，渲染进程将会创建一个回调任务，包含了回调函数 showName、当前发起时间、延迟执行时间，其模拟代码如下所示：
    ```
    struct DelayTask{
    int64 id；
    CallBackFunction cbf;
    int start_time;
    int delay_time;
    };
    DelayTask timerTask;
    timerTask.cbf = showName;
    timerTask.start_time = getCurrentTime(); //获取当前时间
    timerTask.delay_time = 200;//设置延迟执行时间
    ```
    创建好回调任务之后，再将该任务添加到延迟执行队列中。代码如下：
    ```
    delayed_incoming_queue.push(timerTask)；
    ```
    
    现在通过定时器发起的任务就被保存到延迟队列中。
    
    事件循环系统中有一个 **ProcessDelayTask 函数**，该函数是专门用来处理延迟执行任务的。

    处理完消息队列中的一个任务之后，就开始执行 ProcessDelayTask 函数。**ProcessDelayTask 函数会根据发起时间和延迟时间计算出到期的任务，然后依次执行这些到期的任务。**等到期的任务执行完成之后，再继续下一个循环过程。

    通过这样的方式，一个完整的定时器就实现了。

    设置一个定时器，JavaScript 引擎会返回一个**定时器的 ID**。
    
    通常情况下，当一个定时器的任务还没有被执行的时候，也是可以取消的，具体方法是调用 **clearTimeout** 函数，并传入需要取消的定时器的 ID。
    
    浏览器内部实现取消定时器的操作也是非常简单的，就是直接从 **delayed_incoming_queue 延迟队列**中，通过 ID 查找到对应的任务，然后再将其从队列中**删除**掉就可以了。
    
    **使用 setTimeout 的注意事项：**
    
    + 如果当前任务执行时间过久，会影响定时器任务的执行
    
    + 如果 setTimeout 存在嵌套调用，那么系统会设置最短时间间隔为 4 毫秒
    
    + 未激活的页面，setTimeout 执行最小间隔是 1000 毫秒
    
    + 延时执行时间有最大值
    
      Chrome、Safari、Firefox 都是以 32 个 bit 来存储延时值的，32bit 最大只能存放的数字是 2147483647 毫秒，这就意味着，如果 setTimeout 设置的延迟值大于 2147483647 毫秒（大约 24.8 天）时就会溢出，那么相当于延时值被设置为 0 了，这导致定时器会被立即执行。
    
    + 使用 setTimeout 设置的回调函数中的 this 不符合直觉

5. **前端跨页面通信，你知道哪些方法？**
    + 同源页面间的跨页面通信

    + 非同源页面之间的通信