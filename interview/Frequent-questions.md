## 在浏览器里，从输入 URL 到页面展示，这中间发生了什么？
![流程图](https://static001.geekbang.org/resource/image/92/5d/92d73c75308e50d5c06ad44612bcb45d.png)
浏览器进程接收到用户输入的 URL 请求，浏览器进程便将该 URL 转发给网络进程
在网络进程中发起真正的 URL 请求。
接着网络进程接收到了响应头数据，便解析响应头数据，并将数据转发给浏览器进程。
浏览器进程接收到网络进程的响应头数据之后，发送“提交导航 (CommitNavigation)”消息到渲染进程；
渲染进程接收到“提交导航”的消息之后，便开始准备接收 HTML 数据，接收数据的方式是直接和网络进程建立数据管道；
最后渲染进程会向浏览器进程“确认提交”，这是告诉浏览器进程：“已经准备好接受和解析页面数据了”。
浏览器进程接收到渲染进程“提交文档”的消息之后，便开始移除之前旧的文档，然后更新浏览器进程中的页面状态。


用户输入
地址栏会判断输入的关键字是搜索内容，还是请求的 URL。
    如果是搜索内容，地址栏会使用浏览器默认的搜索引擎，来合成新的带搜索关键字的 URL。
    如果判断输入内容符合 URL 规则，那么地址栏会根据规则，把这段内容加上协议，合成为完整的 URL。

当用户输入关键字并键入回车之后，这意味着当前页面即将要被替换成新的页面。
不过在这个流程继续之前，浏览器还给了当前页面一次执行 beforeunload 事件的机会，beforeunload 事件允许页面在退出之前执行一些数据清理操作，还可以询问用户是否要离开当前页面，比如当前页面可能有未提交完成的表单等情况，因此用户可以通过 beforeunload 事件来取消导航，让浏览器不再执行任何后续工作。

当前页面没有监听 beforeunload 事件或者同意了继续后续流程，那么浏览器便进入加载状态。

浏览器进程会通过进程间通信（IPC）把 URL 请求发送至网络进程，网络进程接收到 URL 请求后，会在这里发起真正的 URL 请求流程。
    网络进程会查找本地缓存是否缓存了该资源。
    强缓存：存在且未过期直接使用 否则下一步查找协商缓存。
    协商缓存：无则直接发起请求，请求资源；有且未过期，发起请求询问是否过期，304 则表示未过期，可使用，200 则表示已过期，返回最新内容。

发送请求过程：
    DNS 域名解析：

建立 TCP 连接：

HTTPS 则建立 TLS 连接：

服务器接受数据并响应

网络进程接受响应数据并解析：
    解析响应头：301/302 说明重定向，从响应头 Location 字段中读取重定向的地址，再次发起 HTTP/HTTPS 请求。
            304 表示协商缓存可用，直接读取缓存资源。

收到 200 成功的响应后，表示浏览器可以继续处理该请求。
浏览器根据响应头中的 Content-Type 的值来决定如何显示响应体的内容：
如果是 application/octet-stream 字段，显示数据是字节流类型的，浏览器会将请求提交给下载管理器，导航流程至此结束。
如果是 HTML 等文本或其他资源，浏览器会继续导航流程。

浏览器进程准备渲染进程。

浏览器进程将网络进程接收到的数据交给渲染进程：
    当浏览器进程接收到网络进程的响应头数据之后，便向渲染进程发起“提交文档”的消息；
    渲染进程接收到“提交文档”的消息后，会和网络进程建立传输数据的“管道”；
    等文档数据传输完成之后，渲染进程会返回“确认提交”的消息给浏览器进程；
    浏览器进程在收到“确认提交”的消息后，会更新浏览器界面状态，包括了安全状态、地址栏的 URL、前进后退的历史状态，并更新 Web 页面。

一旦文档被提交，渲染进程便开始页面解析和子资源加载：
    构建 DOM 树：因为浏览器无法直接理解和使用 HTML，所以需要将 HTML 转换为浏览器能够理解的结构——DOM 树。
    样式计算（Recalculate Style）：
        把 CSS 转换为浏览器能够理解的结构：当渲染引擎接收到 CSS 文本时，会执行一个转换操作，将 CSS 文本转换为浏览器可以理解的结构——styleSheets。
        转换样式表中的属性值，使其标准化：需要将所有值转换为渲染引擎容易理解的、标准化的计算值(如 em，red 等)
        计算出 DOM 树中每个节点的具体样式：涉及到 CSS 的继承规则和层叠规则
    布局阶段：计算出 DOM 树中可见元素的几何位置，我们把这个计算过程叫做布局。
        创建布局树：在显示之前，我们还要额外地构建一棵只包含可见元素布局树。
        布局计算：
    渲染引擎还需要为特定的节点生成专用的图层，并生成一棵对应的图层树（LayerTree）。浏览器的页面实际上被分成了很多图层，这些图层叠加后合成了最终的页面。
    通常情况下，并不是布局树的每个节点都包含一个图层，如果一个节点没有对应的层，那么这个节点就从属于父节点的图层。
        拥有层叠上下文属性的元素会被提升为单独的一层。
        需要剪裁（clip）的地方也会被创建为图层。

图层绘制
在完成图层树的构建之后，渲染引擎会对图层树中的每个图层进行绘制：把一个图层的绘制拆分成很多小的绘制指令，然后再把这些指令按照顺序组成一个待绘制列表。在图层绘制阶段，输出的内容就是这些待绘制列表。

栅格化（raster）操作
绘制列表只是用来记录绘制顺序和绘制指令的列表，而实际上绘制操作是由渲染引擎中的合成线程来完成的。
当图层的绘制列表准备好之后，主线程会把该绘制列表提交（commit）给合成线程，合成线程会将图层划分为图块（tile），这些图块的大小通常是 256x256 或者 512x512，然后合成线程会按照视口附近的图块来优先生成位图，实际生成位图的操作是由栅格化来执行的。所谓栅格化，是指将图块转换为位图。图块是栅格化执行的最小单位。
通常，栅格化过程都会使用 GPU 来加速生成，使用 GPU 生成位图的过程叫快速栅格化，或者 GPU 栅格化，生成的位图被保存在 GPU 内存中。

合成和显示
一旦所有图块都被光栅化，合成线程就会生成一个绘制图块的命令——“DrawQuad”，然后将该命令提交给浏览器进程。
浏览器进程里面有一个叫 viz 的组件，用来接收合成线程发过来的 DrawQuad 命令，然后根据 DrawQuad 命令，将其页面内容绘制到内存中，最后再将内存显示在屏幕上。




## 减少重绘和重排(回流)的方法
1. 使用 class 操作样式，而不是频繁操作 style
2. 避免使用 table 布局
3. 批量dom 操作，例如 createDocumentFragment，或者使用框架，例如 React
4. Debounce window resize 事件
5. 对 dom 属性的读写要分离
6. will-change: transform 做优化

1 触发repaint reflow的操作尽量放在一起，比如改变dom高度和设置margin分开写，可能会出发两次重排
2 通过虚拟dom层计算出操作总得差异，一起提交给浏览器。之前还用过createdocumentfragment来汇总append的dom,来减少触发重排重绘次数。